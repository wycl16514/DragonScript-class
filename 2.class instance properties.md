We have enable the definition and instance initialization of a class. Now we look at how to manipulate properties of given class instance, we will adopt the way of python and js, we can add any properties to
class instance at any time, let's add the test case first:

```js
it("should enable parsing for instance property", () => {
        let code =
            `
        class Bird {
            func fly(place ){
                print("The bird is flying at");
                print(place);
            }
        }
        var bird = Bird();
        bird.color = "red";
        `

        let codeToParse = () => {
            createParsingTree(code)
        }

        expect(codeToParse).not.toThrow()

    })
```
Run the test case and make sure it fails. We are using dot operator for adding and writing to properties, for the language format of "someObject.someProperty", actually the dot can be following a call 
such as "someObject.someMethod(1).someProperty", and we can combine the dot operator with call, so we rewrite the call rule as following:

call -> primary call_recursive
call_recursive -> EPSILON | LEFT_PAREN arguments RIGHT_PAREN call_recursive | DOT IDENTIFIER call_recursive

Then we can add code to parser as following:

```js
call = (parent) => {
        this.primary(parent)
        parent = parent.children[0]

        let lastParent = parent
        while (true) {
            parent = this.doCall(lastParent)
            if (!parent) {
                parent = this.doGet(lastParent)
            }
            if (!parent) {
                break
            }

            lastParent = parent
        }

    }

    doCall = (parent) => {
        const callNode = this.createParseTreeNode(parent, "call");

        if (this.matchTokens([Scanner.LEFT_PAREN])) {
            if (parent.attributes) {
                callNode["call_name"] = parent.attributes.value
            }

            parent.children.push(callNode)
            //only identifier is allowed to be name of function
            if (parent.token.token !== Scanner.IDENTIFIER) {
                throw new Error("function name illegal")
            }
            //over the beginning (
            this.advance()

            let callName = "anonymous_call"
            /*
            The anonymous_call is for function call lie getCallBack()(), the second parenthese
            trigger another function call but this time we don't have the function name,
            therefore we use anonymous_call as its name
            */
            if (callNode.call_name) {
                callName = callNode.call_name
            }

            callNode.attributes = {
                values: callName,
            }
            this.argument_list(callNode)
            return callNode
        }

        return null
    }

    doGet = (parent) => {
        const getNode = this.createParseTreeNode(parent, "get")

        if (this.matchTokens([Scanner.DOT])) {
            if (parent.attributes) {
                getNode["instance_name"] = parent.attributes.value
                console.log("getter instance name: ", parent.attributes.value)
            }

            this.advance()
            parent.children.push(getNode)
            //only identifier is allowed to be instance of class
            const token = this.matchTokens([Scanner.IDENTIFIER])
            if (!token) {
                throw new Error("should follow identifier after dot operator")
            }
            getNode.attributes = {
                value: token.lexeme
            }
            this.advance()
            return getNode
        }

        return null
    }
```
In the aboved code, we check the current line of code can be parsed as function call or accessing property on instance or not. The difference between them is check there is a left paren or a dot following the
identifier.


