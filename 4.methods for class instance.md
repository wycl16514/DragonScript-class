In this section, we will see how interpreter can understand and excute methods define on class. Methods are like function call we seen before, the main different is, methods rely on given instance, it may receive data
from parameters and also visiting data fields defined for the given instance. 

But there are several concerns we need to handle, the first is, what if we assign a method of class to a variable and seperate the method call with ints instance as following:

```js
var m = object.method;
m(argument);
```

The second concern is, how about we attach a function to an object instance:

```js
class Box {
}

function noMehod(argument) {
  //do something
}

var box = Box();
box.method = noMethod;
box.method("argument");
```

And we have more tricky case to handle like following:
```js
class Person {
    func sayName() {
        print(this.name);
    }
}

var jane = Person();
jane.name = "Jane";

var bill = Person();
bill.name = "Bill";

bill.sayName = jane.sayName;
bill.sayName();
```
What kind of result would you expect for bill.sayName(), it should print out "Bill" or "Jane"? Our stand is, the "this" wil refer to its original instance, which means bill.sayName will print out "Jane". 

Actually the confusion is caused by the code, one should not assign a method hightly bind with its instance to other instance. Of course, we are still far away from handling those edge cases, we need to handle the normal case first.

The first thing we need to do is to bind functions that are defined inside the body of a class definition with that class, let's give your the test case first:
```js
 it("should enable chaining of call and getter", () => {
        let code = `
        class Bird {
            func fly() {
                print("bird flying");
            }
        }

        func getBird() {
            return Bird();
        }

        var a = getBird;
        a().fly();
        `
        let codeToParse = () => {
            createParsingTree(code)
        }

        expect(codeToParse).not.toThrow()

        code = `
        class Bird{func fly(){print("bird flying");} func win(){}  func feather(){} }  
        var  bird = Bird();
        bird.wind().feather().color = "red";
        `

        codeToParse = () => {
            createParsingTree(code)
        }

        expect(codeToParse).not.toThrow()
    })
```
Run the test and make sure it fails. Our code in previous section can only handling access of fields, if we have method call in the middle of the chain, 
such su show aboved, our code from privious section could not apply, since we need to evaluate the method call then apply the field accessing base on the
return value of the method call.

Let's see how we can change our code to enable the parser to understand field accessing combine with method call, in parser.js we have the following change
of codes:
```js
call = (parent) => {
        this.primary(parent)
        //change here
        /*
        need to check it is beginning with an identifier, then we call check it is
        function call or instance field accessing
        */
        if (parent.children[0].token && parent.children[0].token.token == Scanner.IDENTIFIER) {
            parent["call_name"] = parent.children[0].attributes.value
            //change here
            if (this.matchTokens([Scanner.LEFT_PAREN, Scanner.DOT])) {
                //function call or getter should remove the unused primary node
                parent.children = []
                parent.attributes = {
                    value: parent["call_name"]
                }
            }
            this.doCall(parent)
        }
    }

    doCall = (parent) => {
        //change here
        // do_call -> LEFT_PAREN( argument_list | EPSILON
        if (this.matchTokens([Scanner.LEFT_PAREN])) {
            //change here, already check this
            // //only identifier is allowed to be name of function
            // if (parent.children.length > 0 && parent.children[0].token &&
            //     parent.children[0].token.token !== Scanner.IDENTIFIER) {
            //     throw new Error("function name illegal")
            // }
            //over the left paren
            this.advance()

            const callNode = this.createParseTreeNode(parent, "call")
            //replacing the primary node
            //parent.children.push(callNode)
            parent.children.push(callNode)
            let callName = "anonymous_call"

            if (parent.call_name) {
                callName = parent.call_name
            }
            callNode.attributes = {
                value: callName,
            }
            //error here
            this.argument_list(callNode)
            callNode["parent"] = parent
            parent = callNode
        }

        this.doGet(parent)
    }

    doGet = (parent) => {
        //change heres
        if (this.matchTokens([Scanner.DOT])) {

            this.advance()
            //only identifier is allowed to be instance of class, or name of method call
            const token = this.matchTokens([Scanner.IDENTIFIER])
            if (!token) {
                throw new Error("should follow identifier after dot operator")
            }
            /*
            need to make sure component after . is only an identifier, if it is 
            identifier with lef parent, then it should be a call
            */
            this.advance()
            if (!this.matchTokens([Scanner.LEFT_PAREN])) {
                const getNode = this.createParseTreeNode(parent, "get")
                getNode["parent"] = parent
                parent.children.push(getNode)
                getNode["call_name"] = token.lexeme
                getNode.attributes = {
                    value: token.lexeme,
                }
                this.doCall(getNode)
            } else {
                parent["call_name"] = token.lexeme
                this.doCall(parent)
            }
        }
    }

assignment = (parentNode) => {
        //check whether the left size of = is getter

        this.logicOr(parentNode)
        if (this.matchTokens([Scanner.EQUAL])) {
            /*
            get to last node of parentNode get its lexeme, only legal node on the left
            of = is get or primary
            */
            let lastNode = parentNode
            while (lastNode.children.length > 0) {
                if (lastNode.children.length > 1) {
                    for (let child of lastNode.children) {
                        if (child.name === "get" || child.name === "call") {
                            lastNode = child
                            break
                        }
                    }
                } else {
                    lastNode = lastNode.children[0]
                }
            }

            let isLegalLeft = false
            let lexeme = ""
            if (lastNode.name === "get") {
                //change here
                isLegalLeft = true
            } else if (lastNode.name === "primary" && lastNode.token.token === Scanner.IDENTIFIER) {
                isLegalLeft = true
                lexeme = lastNode.token.lexeme
            }

            if (isLegalLeft) {
                let assignmentNode = this.createParseTreeNode(parentNode, "assignment")
                assignmentNode.attributes = {
                    value: lexeme
                }
                //change here
                assignmentNode["getter"] = lastNode

                //over the equal sign
                this.advance()

                this.expression(assignmentNode)
                parentNode.children.push(assignmentNode)
            } else {
                throw new Error("can only assign to defined identifier")
            }
        } else {
            return
        }
    }
```
In aboved code, when we parsing a call, we need to make sure it is a field accessing or it is just call by checking the symbol following the identifier,
if it is "(" following the identifier, then it is a function call or method call, if it is "." following the identifier, then it is a field accessing.

Since there may be method call and field accessing combine together, we need to check the thing following a "." is a call or it is a field. We do this by 
checking one more symbol after the identifier, if it is "(" following with the identifier then it is a method call, other wise it is a field accessing.

Becuase there may be a field accessing following a method call or a method call following a field accesssing. That's why when we parsing a method call we 
follow the parsing of field accessing immediately. And when we complete the parsing of field accessing, we follow the parsing of method call immediately.

Since we have field accessing, it will complicate the handling of assigment. We will allow identifier and field of an instance at the left of "=". That's why
we need to check the node at the left of "=" in parsing assigment. We go to the first node for expression at the left of "=" and find the last node, when
we encouter a call node we need to check whether there is any method call or field accessing following the code.

When we go to the last node for the expression at the left of "=", we check it is a primary or a get node, if it is, then the left side is legal for assignemnt
otherwise the left should be a "r value" which is not allowed to be assigend.

After complete the aboved code, run the project and input the following code into the console:
```js
recursiveparsetree class Bird{func fly(){print("bird flying");}} func getBird(){return Bird();} var a=getBird; a().fly();
```
And we will get its parsing tree like following:

![截屏2024-09-03 15 44 07](https://github.com/user-attachments/assets/748c6d13-73ae-49d2-8270-47d4197051d8)

As we can see from aboved image that, there is a call named "fly" following a code with name "a". Let's see the parsing tree for another piece of code:
```js
recursiveparsetree class Bird{func fly(){print("bird flying");} func win(){}  func feather(){} }  var  bird = Bird();bird.wind().feather().color = "red";
```
Enter aboved code in the console and we get the following parsing tree:
```js
recursiveparsetree class Bird{func fly(){print("bird flying");} func win(){}  func feather(){} }  var  bird = Bird();bird.wind().feather().color = "red";
```
Then we have the following parsing tree:

![截屏2024-09-03 16 00 23](https://github.com/user-attachments/assets/643ee7ea-b1ac-4c56-adeb-c1032e6f75d2)

We can see from aboved image that, there are two calls then following a field accessing.
