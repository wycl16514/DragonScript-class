In this section, we will see how interpreter can understand and excute methods define on class. Methods are like function call we seen before, the main different is, methods rely on given instance, it may receive data
from parameters and also visiting data fields defined for the given instance. 

But there are several concerns we need to handle, the first is, what if we assign a method of class to a variable and seperate the method call with ints instance as following:

```js
var m = object.method;
m(argument);
```

The second concern is, how about we attach a function to an object instance:

```js
class Box {
}

function noMehod(argument) {
  //do something
}

var box = Box();
box.method = noMethod;
box.method("argument");
```

And we have more tricky case to handle like following:
```js
class Person {
    func sayName() {
        print(this.name);
    }
}

var jane = Person();
jane.name = "Jane";

var bill = Person();
bill.name = "Bill";

bill.sayName = jane.sayName;
bill.sayName();
```
What kind of result would you expect for bill.sayName(), it should print out "Bill" or "Jane"? Our stand is, the "this" wil refer to its original instance, which means bill.sayName will print out "Jane". Actually the
confusion is caused by the code, one should not assign a method hightly bind with its instance to other instance. Of course, we are still far away from handling those edge cases, we need to handle the normal case first.

The first thing we need to do is to bind functions that are defined inside the body of a class definition with that class, let's give your the test case first:
```js
```
